import { useState, useCallback, useEffect } from 'react'
import { supabase } from './supabaseClient'
import { simulateCompositeJS, generateSVGJS, computeL2, buildL2RenderMap } from './checksArtJS'
import { mapCheckAttributes, type CheckStruct } from './utils'
import type { PermutationResult } from './useAllPermutations'
import { readCache, writeCache } from './permutationsCache'

const RANDOM_TOTAL  = 2500   // items loaded for the random browse view

// CheckStruct stored in Supabase has seed as string (bigint serialization)
interface CheckStructJSON {
  stored: {
    composites: number[]
    colorBands: number[]
    gradients: number[]
    divisorIndex: number
    epoch: number
    seed: number
    day: number
  }
  isRevealed: boolean
  seed: string
  checksCount: number
  hasManyChecks: boolean
  composite: number
  isRoot: boolean
  colorBand: number
  gradient: number
  direction: number
  speed: number
}

function fromJSON(j: CheckStructJSON): CheckStruct {
  return { ...j, seed: BigInt(j.seed), stored: { ...j.stored } }
}

// Basic perm row — no join, just scalar columns
interface PermRowBasic {
  keeper_1_id: number
  burner_1_id: number
  keeper_2_id: number
  burner_2_id: number
  abcd_checks: number | null
  abcd_color_band: string | null
  abcd_gradient: string | null
  abcd_speed: string | null
  abcd_shift: string | null
}

// Full row after attaching check structs
export interface PermRow extends PermRowBasic {
  keeper_1: { check_struct: CheckStructJSON }
  burner_1: { check_struct: CheckStructJSON }
  keeper_2: { check_struct: CheckStructJSON }
  burner_2: { check_struct: CheckStructJSON }
}

// Select just the scalar columns — no PostgREST join needed
const PERM_SELECT = `keeper_1_id, burner_1_id, keeper_2_id, burner_2_id, abcd_checks, abcd_color_band, abcd_gradient, abcd_speed, abcd_shift`

// Fetch check_struct for a set of token IDs and return a lookup map
async function fetchCheckStructMap(ids: number[]): Promise<Map<number, CheckStructJSON>> {
  if (!supabase || ids.length === 0) return new Map()
  // Batch to avoid excessively long query strings
  const BATCH = 500
  const map = new Map<number, CheckStructJSON>()
  for (let i = 0; i < ids.length; i += BATCH) {
    const { data, error } = await supabase
      .from('tokenstr_checks')
      .select('token_id, check_struct')
      .in('token_id', ids.slice(i, i + BATCH))
    if (error) throw error
    for (const row of (data ?? []) as { token_id: number; check_struct: CheckStructJSON }[]) {
      map.set(row.token_id, row.check_struct)
    }
  }
  return map
}

// Attach check structs to basic perm rows (rows missing any struct are dropped)
async function attachChecks(basicRows: PermRowBasic[]): Promise<PermRow[]> {
  const uniqueIds = [...new Set(
    basicRows.flatMap(r => [r.keeper_1_id, r.burner_1_id, r.keeper_2_id, r.burner_2_id])
  )]
  const map = await fetchCheckStructMap(uniqueIds)
  return basicRows
    .filter(r =>
      map.has(r.keeper_1_id) && map.has(r.burner_1_id) &&
      map.has(r.keeper_2_id) && map.has(r.burner_2_id)
    )
    .map(r => ({
      ...r,
      keeper_1: { check_struct: map.get(r.keeper_1_id)! },
      burner_1: { check_struct: map.get(r.burner_1_id)! },
      keeper_2: { check_struct: map.get(r.keeper_2_id)! },
      burner_2: { check_struct: map.get(r.burner_2_id)! },
    }))
}

// Composite structs are computed eagerly (fast), SVGs are lazy getters —
// only generated by generateSVGJS when the card first scrolls into view.
function computeAllNodes(
  row: PermRow,
  id0: string, id1: string, id2: string, id3: string,
): Pick<PermutationResult, 'nodeL1a' | 'nodeL1b' | 'nodeAbcd'> {
  try {
    const k1 = fromJSON(row.keeper_1.check_struct)
    const b1 = fromJSON(row.burner_1.check_struct)
    const k2 = fromJSON(row.keeper_2.check_struct)
    const b2 = fromJSON(row.burner_2.check_struct)

    const l1aStruct  = simulateCompositeJS(k1, b1, row.burner_1_id)
    const l1bStruct  = simulateCompositeJS(k2, b2, row.burner_2_id)
    const abcdStruct = computeL2(l1aStruct, l1bStruct)
    const abcdMap    = buildL2RenderMap(l1aStruct, l1bStruct, b1, b2)

    let _l1aSvg:  string | undefined
    let _l1bSvg:  string | undefined
    let _abcdSvg: string | undefined

    return {
      nodeL1a: {
        name: `#${id0}+#${id1}`,
        attributes: mapCheckAttributes(l1aStruct),
        loading: false, error: '',
        get svg() {
          if (_l1aSvg !== undefined) return _l1aSvg
          return (_l1aSvg = generateSVGJS(l1aStruct, new Map<number, CheckStruct>([[row.burner_1_id, b1]])))
        },
      },
      nodeL1b: {
        name: `#${id2}+#${id3}`,
        attributes: mapCheckAttributes(l1bStruct),
        loading: false, error: '',
        get svg() {
          if (_l1bSvg !== undefined) return _l1bSvg
          return (_l1bSvg = generateSVGJS(l1bStruct, new Map<number, CheckStruct>([[row.burner_2_id, b2]])))
        },
      },
      nodeAbcd: {
        name: 'Final Composite',
        attributes: mapCheckAttributes(abcdStruct),
        loading: false, error: '',
        get svg() {
          if (_abcdSvg !== undefined) return _abcdSvg
          return (_abcdSvg = generateSVGJS(abcdStruct, abcdMap))
        },
      },
    }
  } catch (e) {
    const err = String(e)
    return {
      nodeL1a:  { name: `#${id0}+#${id1}`,    svg: '', attributes: [], loading: false, error: err },
      nodeL1b:  { name: `#${id2}+#${id3}`,    svg: '', attributes: [], loading: false, error: err },
      nodeAbcd: { name: 'Final Composite',     svg: '', attributes: [], loading: false, error: err },
    }
  }
}

function rowToPermutationResult(row: PermRow): PermutationResult {
  const id0 = String(row.keeper_1_id)
  const id1 = String(row.burner_1_id)
  const id2 = String(row.keeper_2_id)
  const id3 = String(row.burner_2_id)

  return {
    def: {
      indices:  [0, 1, 2, 3],
      label:    `#${id0}▸#${id1}, #${id2}▸#${id3}`,
      tokenIds: [id0, id1, id2, id3],
    },
    // Individual check SVGs fetched lazily by TreePanel on demand
    nodeA: { name: `Token #${id0}`, svg: '', attributes: [], loading: false, error: '' },
    nodeB: { name: `Token #${id1}`, svg: '', attributes: [], loading: false, error: '' },
    nodeC: { name: `Token #${id2}`, svg: '', attributes: [], loading: false, error: '' },
    nodeD: { name: `Token #${id3}`, svg: '', attributes: [], loading: false, error: '' },
    ...computeAllNodes(row, id0, id1, id2, id3),
  }
}

export interface DBPermutationsState {
  permutations: PermutationResult[]
  loading: boolean
  error: string
  total: number
}

export function usePermutationsDB() {
  const [state, setState] = useState<DBPermutationsState>({
    permutations: [],
    loading: false,
    error: '',
    total: 0,
  })

  const loadRandom = useCallback(async (force = false) => {
    if (!supabase) return

    // Cache hit — skip DB entirely
    if (!force) {
      const cached = readCache()
      if (cached) {
        setState({
          permutations: cached.map(rowToPermutationResult),
          loading: false,
          error: '',
          total: cached.length,
        })
        return
      }
    }

    setState(prev => ({ ...prev, loading: true, error: '', permutations: [] }))
    try {
      const { data, error } = await supabase
        .from('permutations')
        .select(PERM_SELECT)
        .order('rank_score', { ascending: false })
        .limit(RANDOM_TOTAL)

      if (error) throw error

      const basicRows = (data ?? []) as unknown as PermRowBasic[]
      const rows      = await attachChecks(basicRows)

      writeCache(rows)

      setState({
        permutations: rows.map(rowToPermutationResult),
        loading: false,
        error: '',
        total: rows.length,
      })
    } catch (e) {
      const msg = (e as { message?: string })?.message ?? String(e)
      setState(prev => ({ ...prev, loading: false, error: msg }))
    }
  }, [])

  // Client-side Fisher-Yates shuffle of the already-loaded permutations.
  // No re-fetch needed — the ranked set is stable.
  const shuffle = useCallback(() => {
    setState(prev => {
      if (prev.permutations.length === 0) return prev
      const arr = [...prev.permutations]
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1))
        ;[arr[i], arr[j]] = [arr[j], arr[i]]
      }
      return { ...prev, permutations: arr }
    })
  }, [])

  return { state, loadRandom, shuffle }
}

export function usePriceBounds(enabled: boolean) {
  const [bounds, setBounds] = useState<{ min: number; max: number } | null>(null)

  useEffect(() => {
    if (!enabled || !supabase) return
    Promise.all([
      supabase
        .from('tokenstr_checks')
        .select('eth_price')
        .not('eth_price', 'is', null)
        .order('eth_price', { ascending: true })
        .limit(1),
      supabase
        .from('tokenstr_checks')
        .select('eth_price')
        .not('eth_price', 'is', null)
        .order('eth_price', { ascending: false })
        .limit(1),
    ]).then(([minRes, maxRes]) => {
      const minPrice = (minRes.data?.[0] as { eth_price: number } | undefined)?.eth_price ?? 0
      const maxPrice = (maxRes.data?.[0] as { eth_price: number } | undefined)?.eth_price ?? 0
      // Slider bounds = 4 × cheapest individual to 4 × most expensive
      setBounds({ min: minPrice * 4, max: maxPrice * 4 })
    })
  }, [enabled])

  return bounds
}
