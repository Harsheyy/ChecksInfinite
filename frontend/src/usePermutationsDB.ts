import { useState, useCallback, useEffect } from 'react'
import { supabase } from './supabaseClient'
import { simulateCompositeJS, generateSVGJS, computeL2, buildL2RenderMap } from './checksArtJS'
import { mapCheckAttributes, type CheckStruct } from './utils'
import type { PermutationResult } from './useAllPermutations'
import type { Filters } from './components/FilterBar'

const RANDOM_TOTAL  = 2500   // items loaded for the random browse view
const NUM_SEGMENTS  = 5      // parallel fetches to get diverse rows
const SEG_SIZE      = RANDOM_TOTAL / NUM_SEGMENTS  // 500 per segment
const FILTERED_LIMIT = 2500  // max rows returned for a filtered query

// CheckStruct stored in Supabase has seed as string (bigint serialization)
interface CheckStructJSON {
  stored: {
    composites: number[]
    colorBands: number[]
    gradients: number[]
    divisorIndex: number
    epoch: number
    seed: number
    day: number
  }
  isRevealed: boolean
  seed: string
  checksCount: number
  hasManyChecks: boolean
  composite: number
  isRoot: boolean
  colorBand: number
  gradient: number
  direction: number
  speed: number
}

function fromJSON(j: CheckStructJSON): CheckStruct {
  return { ...j, seed: BigInt(j.seed), stored: { ...j.stored } }
}

// Basic perm row — no join, just scalar columns
interface PermRowBasic {
  keeper_1_id: number
  burner_1_id: number
  keeper_2_id: number
  burner_2_id: number
  abcd_checks: number | null
  abcd_color_band: string | null
  abcd_gradient: string | null
  abcd_speed: string | null
  abcd_shift: string | null
}

// Full row after attaching check structs
export interface PermRow extends PermRowBasic {
  keeper_1: { check_struct: CheckStructJSON }
  burner_1: { check_struct: CheckStructJSON }
  keeper_2: { check_struct: CheckStructJSON }
  burner_2: { check_struct: CheckStructJSON }
}

// Select just the scalar columns — no PostgREST join needed
const PERM_SELECT = `keeper_1_id, burner_1_id, keeper_2_id, burner_2_id, abcd_checks, abcd_color_band, abcd_gradient, abcd_speed, abcd_shift`

// Fetch check_struct for a set of token IDs and return a lookup map
async function fetchCheckStructMap(ids: number[]): Promise<Map<number, CheckStructJSON>> {
  if (!supabase || ids.length === 0) return new Map()
  // Batch to avoid excessively long query strings
  const BATCH = 500
  const map = new Map<number, CheckStructJSON>()
  for (let i = 0; i < ids.length; i += BATCH) {
    const { data, error } = await supabase
      .from('tokenstr_checks')
      .select('token_id, check_struct')
      .in('token_id', ids.slice(i, i + BATCH))
    if (error) throw error
    for (const row of (data ?? []) as { token_id: number; check_struct: CheckStructJSON }[]) {
      map.set(row.token_id, row.check_struct)
    }
  }
  return map
}

// Attach check structs to basic perm rows (rows missing any struct are dropped)
async function attachChecks(basicRows: PermRowBasic[]): Promise<PermRow[]> {
  const uniqueIds = [...new Set(
    basicRows.flatMap(r => [r.keeper_1_id, r.burner_1_id, r.keeper_2_id, r.burner_2_id])
  )]
  const map = await fetchCheckStructMap(uniqueIds)
  return basicRows
    .filter(r =>
      map.has(r.keeper_1_id) && map.has(r.burner_1_id) &&
      map.has(r.keeper_2_id) && map.has(r.burner_2_id)
    )
    .map(r => ({
      ...r,
      keeper_1: { check_struct: map.get(r.keeper_1_id)! },
      burner_1: { check_struct: map.get(r.burner_1_id)! },
      keeper_2: { check_struct: map.get(r.keeper_2_id)! },
      burner_2: { check_struct: map.get(r.burner_2_id)! },
    }))
}

// Composite structs are computed eagerly (fast), SVGs are lazy getters —
// only generated by generateSVGJS when the card first scrolls into view.
function computeAllNodes(
  row: PermRow,
  id0: string, id1: string, id2: string, id3: string,
): Pick<PermutationResult, 'nodeL1a' | 'nodeL1b' | 'nodeAbcd'> {
  try {
    const k1 = fromJSON(row.keeper_1.check_struct)
    const b1 = fromJSON(row.burner_1.check_struct)
    const k2 = fromJSON(row.keeper_2.check_struct)
    const b2 = fromJSON(row.burner_2.check_struct)

    const l1aStruct  = simulateCompositeJS(k1, b1, row.burner_1_id)
    const l1bStruct  = simulateCompositeJS(k2, b2, row.burner_2_id)
    const abcdStruct = computeL2(l1aStruct, l1bStruct)
    const abcdMap    = buildL2RenderMap(l1aStruct, l1bStruct, b1, b2)

    let _l1aSvg:  string | undefined
    let _l1bSvg:  string | undefined
    let _abcdSvg: string | undefined

    return {
      nodeL1a: {
        name: `#${id0}+#${id1}`,
        attributes: mapCheckAttributes(l1aStruct),
        loading: false, error: '',
        get svg() {
          if (_l1aSvg !== undefined) return _l1aSvg
          return (_l1aSvg = generateSVGJS(l1aStruct, new Map<number, CheckStruct>([[row.burner_1_id, b1]])))
        },
      },
      nodeL1b: {
        name: `#${id2}+#${id3}`,
        attributes: mapCheckAttributes(l1bStruct),
        loading: false, error: '',
        get svg() {
          if (_l1bSvg !== undefined) return _l1bSvg
          return (_l1bSvg = generateSVGJS(l1bStruct, new Map<number, CheckStruct>([[row.burner_2_id, b2]])))
        },
      },
      nodeAbcd: {
        name: 'Final Composite',
        attributes: mapCheckAttributes(abcdStruct),
        loading: false, error: '',
        get svg() {
          if (_abcdSvg !== undefined) return _abcdSvg
          return (_abcdSvg = generateSVGJS(abcdStruct, abcdMap))
        },
      },
    }
  } catch (e) {
    const err = String(e)
    return {
      nodeL1a:  { name: `#${id0}+#${id1}`,    svg: '', attributes: [], loading: false, error: err },
      nodeL1b:  { name: `#${id2}+#${id3}`,    svg: '', attributes: [], loading: false, error: err },
      nodeAbcd: { name: 'Final Composite',     svg: '', attributes: [], loading: false, error: err },
    }
  }
}

function rowToPermutationResult(row: PermRow): PermutationResult {
  const id0 = String(row.keeper_1_id)
  const id1 = String(row.burner_1_id)
  const id2 = String(row.keeper_2_id)
  const id3 = String(row.burner_2_id)

  return {
    def: {
      indices:  [0, 1, 2, 3],
      label:    `#${id0}▸#${id1}, #${id2}▸#${id3}`,
      tokenIds: [id0, id1, id2, id3],
    },
    // Individual check SVGs fetched lazily by TreePanel on demand
    nodeA: { name: `Token #${id0}`, svg: '', attributes: [], loading: false, error: '' },
    nodeB: { name: `Token #${id1}`, svg: '', attributes: [], loading: false, error: '' },
    nodeC: { name: `Token #${id2}`, svg: '', attributes: [], loading: false, error: '' },
    nodeD: { name: `Token #${id3}`, svg: '', attributes: [], loading: false, error: '' },
    ...computeAllNodes(row, id0, id1, id2, id3),
  }
}

export interface DBPermutationsState {
  permutations: PermutationResult[]
  loading: boolean
  error: string
  total: number
}

export function usePermutationsDB() {
  const [state, setState] = useState<DBPermutationsState>({
    permutations: [],
    loading: false,
    error: '',
    total: 0,
  })

  // Load filtered results (up to FILTERED_LIMIT rows, all server-side filtered)
  const load = useCallback(async (filters: Filters) => {
    if (!supabase) return
    setState(prev => ({ ...prev, loading: true, error: '', permutations: [] }))
    try {
      let q = supabase
        .from('permutations')
        .select(PERM_SELECT, { count: 'exact' })
        .range(0, FILTERED_LIMIT - 1)

      if (filters.checks)    q = q.eq('abcd_checks',     Number(filters.checks))
      if (filters.colorBand) q = q.eq('abcd_color_band', filters.colorBand)
      if (filters.gradient)  q = q.eq('abcd_gradient',   filters.gradient)
      if (filters.speed)     q = q.eq('abcd_speed',      filters.speed)
      if (filters.shift)     q = q.eq('abcd_shift',      filters.shift)

      const idList = filters.idInput.trim()
        ? filters.idInput.split(',').map(s => Number(s.trim())).filter(n => !isNaN(n) && n > 0)
        : []

      if (idList.length > 0) {
        const useAnd = idList.length >= 4 && filters.idMode === 'and'
        if (useAnd) {
          q = q.in('keeper_1_id', idList).in('burner_1_id', idList).in('keeper_2_id', idList).in('burner_2_id', idList)
        } else {
          const ids = idList.join(',')
          q = q.or(`keeper_1_id.in.(${ids}),burner_1_id.in.(${ids}),keeper_2_id.in.(${ids}),burner_2_id.in.(${ids})`)
        }
      }

      if (filters.minCost !== null) q = q.gte('total_cost', filters.minCost)
      if (filters.maxCost !== null) q = q.lte('total_cost', filters.maxCost)

      const { data, error, count } = await q
      if (error) throw error

      const basicRows = (data ?? []) as unknown as PermRowBasic[]
      const rows = await attachChecks(basicRows)
      setState({
        permutations: rows.map(rowToPermutationResult),
        loading: false,
        error: '',
        total: count ?? 0,
      })
    } catch (e) {
      const msg = (e as { message?: string })?.message ?? String(e)
      setState(prev => ({ ...prev, loading: false, error: msg }))
    }
  }, [])

  // Fetch RANDOM_TOTAL items from NUM_SEGMENTS non-overlapping random sections
  // of the full dataset — fast (parallel range scans) and visually diverse.
  const loadRandom = useCallback(async () => {
    if (!supabase) return
    setState(prev => ({ ...prev, loading: true, error: '', permutations: [] }))
    try {
      // Get total row count
      const { count: totalCount, error: cntErr } = await supabase
        .from('permutations')
        .select('keeper_1_id', { count: 'exact', head: true })
      if (cntErr) throw cntErr
      const total = totalCount ?? 0

      if (total === 0) {
        setState({ permutations: [], loading: false, error: '', total: 0 })
        return
      }

      // Split dataset into NUM_SEGMENTS equal bands; pick a random start in each
      const segLen = Math.floor(total / NUM_SEGMENTS)
      const offsets = Array.from({ length: NUM_SEGMENTS }, (_, i) => {
        const lo = i * segLen
        const hi = Math.max(lo, (i + 1) * segLen - SEG_SIZE)
        return lo + Math.floor(Math.random() * Math.max(1, hi - lo + 1))
      })

      // Step 1: fetch basic perm rows in parallel (no join — no 500 errors)
      const results = await Promise.all(
        offsets.map(offset =>
          supabase!
            .from('permutations')
            .select(PERM_SELECT)
            .range(offset, offset + SEG_SIZE - 1)
        )
      )
      for (const r of results) { if (r.error) throw r.error }
      const basicRows = results.flatMap(r => (r.data ?? []) as unknown as PermRowBasic[])

      // Step 2: fetch all needed check_structs in one batched query
      const rows = await attachChecks(basicRows)

      setState({
        permutations: rows.map(rowToPermutationResult),
        loading: false,
        error: '',
        total,
      })
    } catch (e) {
      const msg = (e as { message?: string })?.message ?? String(e)
      setState(prev => ({ ...prev, loading: false, error: msg }))
    }
  }, [])

  return { state, load, loadRandom }
}

export function usePriceBounds(enabled: boolean) {
  const [bounds, setBounds] = useState<{ min: number; max: number } | null>(null)

  useEffect(() => {
    if (!enabled || !supabase) return
    Promise.all([
      supabase
        .from('tokenstr_checks')
        .select('eth_price')
        .not('eth_price', 'is', null)
        .order('eth_price', { ascending: true })
        .limit(1),
      supabase
        .from('tokenstr_checks')
        .select('eth_price')
        .not('eth_price', 'is', null)
        .order('eth_price', { ascending: false })
        .limit(1),
    ]).then(([minRes, maxRes]) => {
      const minPrice = (minRes.data?.[0] as { eth_price: number } | undefined)?.eth_price ?? 0
      const maxPrice = (maxRes.data?.[0] as { eth_price: number } | undefined)?.eth_price ?? 0
      // Slider bounds = 4 × cheapest individual to 4 × most expensive
      setBounds({ min: minPrice * 4, max: maxPrice * 4 })
    })
  }, [enabled])

  return bounds
}
