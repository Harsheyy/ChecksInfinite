import { useState, useCallback } from 'react'
import { supabase } from './supabaseClient'
import { simulateCompositeJS, generateSVGJS, computeL2, buildL2RenderMap } from './checksArtJS'
import { mapCheckAttributes, type CheckStruct } from './utils'
import type { PermutationResult } from './useAllPermutations'
import type { Filters } from './components/FilterBar'

const RANDOM_TOTAL  = 2500   // items loaded for the random browse view
const NUM_SEGMENTS  = 5      // parallel fetches to get diverse rows
const SEG_SIZE      = RANDOM_TOTAL / NUM_SEGMENTS  // 500 per segment
const FILTERED_LIMIT = 2500  // max rows returned for a filtered query

// CheckStruct stored in Supabase has seed as string (bigint serialization)
interface CheckStructJSON {
  stored: {
    composites: number[]
    colorBands: number[]
    gradients: number[]
    divisorIndex: number
    epoch: number
    seed: number
    day: number
  }
  isRevealed: boolean
  seed: string
  checksCount: number
  hasManyChecks: boolean
  composite: number
  isRoot: boolean
  colorBand: number
  gradient: number
  direction: number
  speed: number
}

function fromJSON(j: CheckStructJSON): CheckStruct {
  return { ...j, seed: BigInt(j.seed), stored: { ...j.stored } }
}

interface ChecksRow {
  check_struct: CheckStructJSON
}

interface PermRow {
  keeper_1_id: number
  burner_1_id: number
  keeper_2_id: number
  burner_2_id: number
  abcd_checks: number | null
  abcd_color_band: string | null
  abcd_gradient: string | null
  abcd_speed: string | null
  abcd_shift: string | null
  keeper_1: ChecksRow
  burner_1: ChecksRow
  keeper_2: ChecksRow
  burner_2: ChecksRow
}

const QUERY_SELECT = `
  keeper_1_id, burner_1_id, keeper_2_id, burner_2_id,
  abcd_checks, abcd_color_band, abcd_gradient, abcd_speed, abcd_shift,
  keeper_1:checks!keeper_1_id(check_struct),
  burner_1:checks!burner_1_id(check_struct),
  keeper_2:checks!keeper_2_id(check_struct),
  burner_2:checks!burner_2_id(check_struct)
`

// Composite structs are computed eagerly (fast), SVGs are lazy getters —
// only generated by generateSVGJS when the card first scrolls into view.
function computeAllNodes(
  row: PermRow,
  id0: string, id1: string, id2: string, id3: string,
): Pick<PermutationResult, 'nodeL1a' | 'nodeL1b' | 'nodeAbcd'> {
  try {
    const k1 = fromJSON(row.keeper_1.check_struct)
    const b1 = fromJSON(row.burner_1.check_struct)
    const k2 = fromJSON(row.keeper_2.check_struct)
    const b2 = fromJSON(row.burner_2.check_struct)

    const l1aStruct  = simulateCompositeJS(k1, b1, row.burner_1_id)
    const l1bStruct  = simulateCompositeJS(k2, b2, row.burner_2_id)
    const abcdStruct = computeL2(l1aStruct, l1bStruct)
    const abcdMap    = buildL2RenderMap(l1aStruct, l1bStruct, b1, b2)

    let _l1aSvg:  string | undefined
    let _l1bSvg:  string | undefined
    let _abcdSvg: string | undefined

    return {
      nodeL1a: {
        name: `#${id0}+#${id1}`,
        attributes: mapCheckAttributes(l1aStruct),
        loading: false, error: '',
        get svg() {
          if (_l1aSvg !== undefined) return _l1aSvg
          return (_l1aSvg = generateSVGJS(l1aStruct, new Map<number, CheckStruct>([[row.burner_1_id, b1]])))
        },
      },
      nodeL1b: {
        name: `#${id2}+#${id3}`,
        attributes: mapCheckAttributes(l1bStruct),
        loading: false, error: '',
        get svg() {
          if (_l1bSvg !== undefined) return _l1bSvg
          return (_l1bSvg = generateSVGJS(l1bStruct, new Map<number, CheckStruct>([[row.burner_2_id, b2]])))
        },
      },
      nodeAbcd: {
        name: 'Final Composite',
        attributes: mapCheckAttributes(abcdStruct),
        loading: false, error: '',
        get svg() {
          if (_abcdSvg !== undefined) return _abcdSvg
          return (_abcdSvg = generateSVGJS(abcdStruct, abcdMap))
        },
      },
    }
  } catch (e) {
    const err = String(e)
    return {
      nodeL1a:  { name: `#${id0}+#${id1}`,    svg: '', attributes: [], loading: false, error: err },
      nodeL1b:  { name: `#${id2}+#${id3}`,    svg: '', attributes: [], loading: false, error: err },
      nodeAbcd: { name: 'Final Composite',     svg: '', attributes: [], loading: false, error: err },
    }
  }
}

function rowToPermutationResult(row: PermRow): PermutationResult {
  const id0 = String(row.keeper_1_id)
  const id1 = String(row.burner_1_id)
  const id2 = String(row.keeper_2_id)
  const id3 = String(row.burner_2_id)

  return {
    def: {
      indices:  [0, 1, 2, 3],
      label:    `#${id0}▸#${id1}, #${id2}▸#${id3}`,
      tokenIds: [id0, id1, id2, id3],
    },
    // Individual check SVGs fetched lazily by TreeModal on demand
    nodeA: { name: `Token #${id0}`, svg: '', attributes: [], loading: false, error: '' },
    nodeB: { name: `Token #${id1}`, svg: '', attributes: [], loading: false, error: '' },
    nodeC: { name: `Token #${id2}`, svg: '', attributes: [], loading: false, error: '' },
    nodeD: { name: `Token #${id3}`, svg: '', attributes: [], loading: false, error: '' },
    ...computeAllNodes(row, id0, id1, id2, id3),
  }
}

export interface DBPermutationsState {
  permutations: PermutationResult[]
  loading: boolean
  error: string
  total: number
}

export function usePermutationsDB() {
  const [state, setState] = useState<DBPermutationsState>({
    permutations: [],
    loading: false,
    error: '',
    total: 0,
  })

  // Load filtered results (up to FILTERED_LIMIT rows, all server-side filtered)
  const load = useCallback(async (filters: Filters) => {
    if (!supabase) return
    setState(prev => ({ ...prev, loading: true, error: '', permutations: [] }))
    try {
      let q = supabase
        .from('permutations')
        .select(QUERY_SELECT, { count: 'exact' })
        .range(0, FILTERED_LIMIT - 1)

      if (filters.checks)    q = q.eq('abcd_checks',     Number(filters.checks))
      if (filters.colorBand) q = q.eq('abcd_color_band', filters.colorBand)
      if (filters.gradient)  q = q.eq('abcd_gradient',   filters.gradient)
      if (filters.speed)     q = q.eq('abcd_speed',      filters.speed)
      if (filters.shift)     q = q.eq('abcd_shift',      filters.shift)

      const { data, error, count } = await q
      if (error) throw error

      const rows = (data ?? []) as unknown as PermRow[]
      setState({
        permutations: rows.map(rowToPermutationResult),
        loading: false,
        error: '',
        total: count ?? 0,
      })
    } catch (e) {
      setState(prev => ({ ...prev, loading: false, error: String(e) }))
    }
  }, [])

  // Fetch RANDOM_TOTAL items from NUM_SEGMENTS non-overlapping random sections
  // of the full dataset — fast (parallel range scans) and visually diverse.
  const loadRandom = useCallback(async () => {
    if (!supabase) return
    setState(prev => ({ ...prev, loading: true, error: '', permutations: [] }))
    try {
      // Get total row count
      const { count: totalCount, error: cntErr } = await supabase
        .from('permutations')
        .select('keeper_1_id', { count: 'exact', head: true })
      if (cntErr) throw cntErr
      const total = totalCount ?? 0

      if (total === 0) {
        setState({ permutations: [], loading: false, error: '', total: 0 })
        return
      }

      // Split dataset into NUM_SEGMENTS equal bands; pick a random start in each
      const segLen = Math.floor(total / NUM_SEGMENTS)
      const offsets = Array.from({ length: NUM_SEGMENTS }, (_, i) => {
        const lo = i * segLen
        const hi = Math.max(lo, (i + 1) * segLen - SEG_SIZE)
        return lo + Math.floor(Math.random() * Math.max(1, hi - lo + 1))
      })

      const results = await Promise.all(
        offsets.map(offset =>
          supabase!
            .from('permutations')
            .select(QUERY_SELECT)
            .range(offset, offset + SEG_SIZE - 1)
        )
      )

      const allRows = results.flatMap(r => (r.data ?? []) as unknown as PermRow[])
      setState({
        permutations: allRows.map(rowToPermutationResult),
        loading: false,
        error: '',
        total,
      })
    } catch (e) {
      setState(prev => ({ ...prev, loading: false, error: String(e) }))
    }
  }, [])

  return { state, load, loadRandom }
}
