# UX Fixes Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Four UX improvements — click-outside panel dismiss, checks filter cleanup, ID input filter, and a cost range slider for Token Works.

**Architecture:** Frontend changes are isolated to `FilterBar.tsx`, `InfiniteGrid.tsx`, `App.tsx`, and `index.css`. Backend changes add `eth_price` to `tokenstr_checks` and `total_cost` to `permutations` via a migration + backfill script + webhook update.

**Tech Stack:** React/TypeScript/Vite, Vitest, Supabase PostgREST, viem, Deno edge functions

---

### Task 1: Click-outside to close side panel

**Files:**
- Modify: `frontend/src/components/InfiniteGrid.tsx`

**Step 1: Add a mousedown handler to the grid viewport**

In `InfiniteGrid.tsx`, add a `handleBackdropMouseDown` function and attach it to **both** grid viewport `<div>` elements (the non-looping and looping paths). The handler closes the panel only when the click does NOT land on a `.perm-card`.

```tsx
function handleBackdropMouseDown(e: React.MouseEvent<HTMLDivElement>) {
  if (selected === null) return
  const target = e.target as Element
  if (!target.closest('.perm-card')) setSelected(null)
}
```

Attach to the small-grid viewport:
```tsx
<div
  className={`grid-viewport${hasFilters ? ' grid-viewport--with-filters' : ''}`}
  ref={containerRef}
  onMouseDown={handleBackdropMouseDown}
>
```

Attach to the looping-grid viewport:
```tsx
<div
  className={`grid-viewport${hasFilters ? ' grid-viewport--with-filters' : ''}`}
  ref={containerRef}
  onScroll={handleScroll}
  onMouseDown={handleBackdropMouseDown}
>
```

**Step 2: Manual test**

Run `cd frontend && npm run dev`, open the app, click a card to open the panel, then click blank grid space — panel should close. Click a different card — panel should switch, not close.

**Step 3: Commit**

```bash
git add frontend/src/components/InfiniteGrid.tsx
git commit -m "feat: click blank grid space to close side panel"
```

---

### Task 2: Checks filter reorder and cleanup

**Files:**
- Modify: `frontend/src/components/FilterBar.tsx`
- Modify: `frontend/src/components/FilterBar.test.tsx`

**Step 1: Write failing test**

In `FilterBar.test.tsx`, update the `renders 5 select dropdowns` test and add a new one verifying the checks options order. Add inside the `FilterBar` describe block:

```tsx
it('Checks dropdown has options 20, 10, 5, 4, 1 in that order (no 40 or 80)', () => {
  render(<FilterBar filters={emptyFilters()} onChange={vi.fn()} visible={24} />)
  const selects = screen.getAllByRole('combobox')
  const checksSelect = selects[0]
  const options = Array.from(checksSelect.querySelectorAll('option'))
    .map(o => o.value)
    .filter(v => v !== '')
  expect(options).toEqual(['20', '10', '5', '4', '1'])
})
```

**Step 2: Run test to verify it fails**

```bash
cd frontend && npx vitest run src/components/FilterBar.test.tsx
```
Expected: FAIL — options currently include 40 and 80.

**Step 3: Update CHECKS_OPTIONS in FilterBar.tsx**

```ts
const CHECKS_OPTIONS = ['20', '10', '5', '4', '1']
```

**Step 4: Update the stale test that uses '80'**

In `FilterBar.test.tsx`, find the `matchesFilters` describe block tests that pass `checks: '80'`. These test `matchesFilters` logic (which is independent of dropdown options), so they remain valid — no change needed there. But the `calls onChange with a select changes` test uses value `'80'`:

```tsx
// Change from:
fireEvent.change(selects[0], { target: { value: '80' } })
expect(onChange).toHaveBeenCalledWith({ ...emptyFilters(), checks: '80' })

// Change to:
fireEvent.change(selects[0], { target: { value: '20' } })
expect(onChange).toHaveBeenCalledWith({ ...emptyFilters(), checks: '20' })
```

**Step 5: Run tests**

```bash
cd frontend && npx vitest run src/components/FilterBar.test.tsx
```
Expected: all pass.

**Step 6: Commit**

```bash
git add frontend/src/components/FilterBar.tsx frontend/src/components/FilterBar.test.tsx
git commit -m "feat: reorder checks filter [20,10,5,4,1], remove 40 and 80"
```

---

### Task 3: ID filter — Filters type, emptyFilters, matchesFilters

**Files:**
- Modify: `frontend/src/components/FilterBar.tsx`
- Modify: `frontend/src/components/FilterBar.test.tsx`

**Step 1: Write failing tests for matchesFilters ID logic**

Add to `FilterBar.test.tsx` inside the `matchesFilters` describe block:

```tsx
describe('matchesFilters — ID filter', () => {
  const attrs: Attribute[] = [{ trait_type: 'Checks', value: '1' }]

  it('passes when idInput is empty', () => {
    expect(matchesFilters(attrs, emptyFilters(), ['10', '20', '30', '40'])).toBe(true)
  })

  it('OR: passes when any token ID is in the entered set', () => {
    const f = { ...emptyFilters(), idInput: '10, 99' }
    expect(matchesFilters(attrs, f, ['10', '20', '30', '40'])).toBe(true)
  })

  it('OR: fails when no token ID is in the entered set', () => {
    const f = { ...emptyFilters(), idInput: '99, 88' }
    expect(matchesFilters(attrs, f, ['10', '20', '30', '40'])).toBe(false)
  })

  it('AND: passes when all 4 token IDs are in the entered set', () => {
    const f = { ...emptyFilters(), idInput: '10, 20, 30, 40, 50', idMode: 'and' as const }
    expect(matchesFilters(attrs, f, ['10', '20', '30', '40'])).toBe(true)
  })

  it('AND: fails when any token ID is not in the entered set', () => {
    const f = { ...emptyFilters(), idInput: '10, 20, 30, 50, 60', idMode: 'and' as const }
    expect(matchesFilters(attrs, f, ['10', '20', '30', '40'])).toBe(false)
  })

  it('uses OR when <=4 IDs regardless of idMode', () => {
    // Only 3 IDs — AND toggle not visible, so always OR
    const f = { ...emptyFilters(), idInput: '10, 20, 30', idMode: 'and' as const }
    expect(matchesFilters(attrs, f, ['10', '99', '99', '99'])).toBe(true)
  })

  it('passes when no tokenIds provided (unrevealed / chain mode)', () => {
    const f = { ...emptyFilters(), idInput: '10, 20' }
    expect(matchesFilters(attrs, f, undefined)).toBe(true)
  })
})
```

Also update `emptyFilters` test:
```tsx
it('returns all empty strings / defaults', () => {
  const f = emptyFilters()
  expect(f.checks).toBe('')
  expect(f.colorBand).toBe('')
  expect(f.gradient).toBe('')
  expect(f.speed).toBe('')
  expect(f.shift).toBe('')
  expect(f.idInput).toBe('')
  expect(f.idMode).toBe('and')
  expect(f.minCost).toBeNull()
  expect(f.maxCost).toBeNull()
})
```

**Step 2: Run to verify fails**

```bash
cd frontend && npx vitest run src/components/FilterBar.test.tsx
```
Expected: FAIL — `idInput`, `idMode`, `minCost`, `maxCost` don't exist yet.

**Step 3: Update Filters interface and emptyFilters in FilterBar.tsx**

```ts
export interface Filters {
  checks: string
  colorBand: string
  gradient: string
  speed: string
  shift: string
  idInput: string
  idMode: 'and' | 'or'
  minCost: number | null
  maxCost: number | null
}

export function emptyFilters(): Filters {
  return {
    checks: '', colorBand: '', gradient: '', speed: '', shift: '',
    idInput: '', idMode: 'and',
    minCost: null, maxCost: null,
  }
}
```

**Step 4: Export a hasActiveFilters helper (replaces Object.values check in App.tsx)**

Add to `FilterBar.tsx`:
```ts
export function hasActiveFilters(f: Filters): boolean {
  return !!(
    f.checks || f.colorBand || f.gradient || f.speed || f.shift ||
    f.idInput.trim() || f.minCost !== null || f.maxCost !== null
  )
}
```

**Step 5: Update matchesFilters signature and add ID logic**

```ts
export function matchesFilters(
  attributes: Attribute[],
  filters: Filters,
  tokenIds?: string[],
): boolean {
  function check(key: keyof Pick<Filters, 'checks' | 'colorBand' | 'gradient' | 'speed' | 'shift'>, traitType: string): boolean {
    if (!filters[key]) return true
    const attr = attributes.find(a => a.trait_type === traitType)
    if (!attr) return true
    return filters[key] === attr.value
  }

  const attrMatch =
    check('checks', 'Checks') &&
    check('colorBand', 'Color Band') &&
    check('gradient', 'Gradient') &&
    check('speed', 'Speed') &&
    check('shift', 'Shift')

  if (!attrMatch) return false

  // ID filter: only applied when we have token IDs to check
  const trimmed = filters.idInput.trim()
  if (trimmed && tokenIds) {
    const entered = trimmed.split(',').map(s => s.trim()).filter(Boolean)
    if (entered.length === 0) return true
    const enteredSet = new Set(entered)
    const useAnd = entered.length > 4 && filters.idMode === 'and'
    if (useAnd) {
      return tokenIds.every(id => enteredSet.has(id))
    } else {
      return tokenIds.some(id => enteredSet.has(id))
    }
  }

  return true
}
```

**Step 6: Run tests**

```bash
cd frontend && npx vitest run src/components/FilterBar.test.tsx
```
Expected: all pass.

**Step 7: Fix App.tsx to use the new hasActiveFilters helper and pass tokenIds to matchesFilters**

In `App.tsx`:

```tsx
// Replace import line:
import { FilterBar, emptyFilters, hasActiveFilters, matchesFilters, type Filters } from './components/FilterBar'

// Replace:
const hasActiveFilters = Object.values(filters).some(v => v !== '')
// With:
const activeFilters = hasActiveFilters(filters)

// Replace all usages of hasActiveFilters with activeFilters in the file
// (3 occurrences: useEffect dep, conditional load, showFilters computation)

// Update showFlags to pass tokenIds:
const showFlags = (isMyChecksMode || !dbMode)
  ? permutations.map(p => {
      if (p.nodeAbcd.loading || p.nodeAbcd.error) return true
      const [p0, p1, p2, p3] = p.def.indices
      const tids = p.def.tokenIds ?? [ids[p0], ids[p1], ids[p2], ids[p3]]
      return matchesFilters(p.nodeAbcd.attributes, filters, tids)
    })
  : permutations.map(() => true)
```

**Step 8: Run all tests**

```bash
cd frontend && npx vitest run
```
Expected: all pass.

**Step 9: Commit**

```bash
git add frontend/src/components/FilterBar.tsx frontend/src/components/FilterBar.test.tsx frontend/src/App.tsx
git commit -m "feat: add ID filter logic to Filters type and matchesFilters"
```

---

### Task 4: ID filter — UI in FilterBar

**Files:**
- Modify: `frontend/src/components/FilterBar.tsx`
- Modify: `frontend/src/index.css`

**Step 1: Write failing UI test**

Add to `FilterBar.test.tsx` in the `FilterBar` describe block:

```tsx
it('renders Check IDs input field', () => {
  render(<FilterBar filters={emptyFilters()} onChange={vi.fn()} visible={24} />)
  expect(screen.getByPlaceholderText(/e\.g\. 123, 456/)).toBeInTheDocument()
})

it('does not show AND/OR toggle for <=4 IDs', () => {
  const f = { ...emptyFilters(), idInput: '1, 2, 3, 4' }
  render(<FilterBar filters={f} onChange={vi.fn()} visible={24} />)
  expect(screen.queryByRole('button', { name: /AND/ })).toBeNull()
  expect(screen.queryByRole('button', { name: /OR/ })).toBeNull()
})

it('shows AND/OR toggle when >4 IDs entered', () => {
  const f = { ...emptyFilters(), idInput: '1, 2, 3, 4, 5' }
  render(<FilterBar filters={f} onChange={vi.fn()} visible={24} />)
  expect(screen.getByRole('button', { name: /AND/ })).toBeInTheDocument()
  expect(screen.getByRole('button', { name: /OR/ })).toBeInTheDocument()
})

it('AND/OR toggle switches idMode', () => {
  const onChange = vi.fn()
  const f = { ...emptyFilters(), idInput: '1, 2, 3, 4, 5', idMode: 'and' as const }
  render(<FilterBar filters={f} onChange={onChange} visible={24} />)
  fireEvent.click(screen.getByRole('button', { name: /OR/ }))
  expect(onChange).toHaveBeenCalledWith(expect.objectContaining({ idMode: 'or' }))
})
```

**Step 2: Run to verify fails**

```bash
cd frontend && npx vitest run src/components/FilterBar.test.tsx
```
Expected: FAIL.

**Step 3: Add ID filter UI to FilterBar.tsx**

Add a helper to parse the ID count:
```tsx
function parseIdCount(input: string): number {
  return input.split(',').map(s => s.trim()).filter(Boolean).length
}
```

In the `FilterBar` JSX, after the last `FilterSelect`, add before the count span:

```tsx
{/* ID input */}
<label className="filter-select-label">
  <span className="filter-select-name">IDs</span>
  <input
    className="filter-id-input"
    type="text"
    placeholder="e.g. 123, 456"
    value={filters.idInput}
    onChange={e => update('idInput', e.target.value)}
  />
</label>

{/* AND/OR toggle — only when >4 IDs */}
{parseIdCount(filters.idInput) > 4 && (
  <div className="filter-mode-toggle">
    <button
      type="button"
      className={`filter-mode-btn${filters.idMode === 'and' ? ' filter-mode-btn--active' : ''}`}
      onClick={() => update('idMode', 'and')}
      aria-label="AND"
    >AND</button>
    <button
      type="button"
      className={`filter-mode-btn${filters.idMode === 'or' ? ' filter-mode-btn--active' : ''}`}
      onClick={() => update('idMode', 'or')}
      aria-label="OR"
    >OR</button>
  </div>
)}
```

Note: `update` only works for `string` values. Change the `update` helper to accept `string | 'and' | 'or'`:

```tsx
function update(key: keyof Filters, val: string) {
  onChange({ ...filters, [key]: val })
}
```

This already works since `'and'` and `'or'` are strings.

**Step 4: Add CSS for new elements in index.css**

```css
.filter-id-input {
  background: #1a1a1a;
  border: 1px solid #333;
  border-radius: 2px;
  color: #ccc;
  font-family: inherit;
  font-size: 0.72rem;
  padding: 0.15rem 0.4rem;
  width: 120px;
}
.filter-id-input:focus { outline: 1px solid #555; }
.filter-id-input::placeholder { color: #555; }

.filter-mode-toggle {
  display: flex;
  border: 1px solid #333;
  border-radius: 2px;
  overflow: hidden;
  flex-shrink: 0;
}

.filter-mode-btn {
  background: transparent;
  border: none;
  color: #666;
  font-family: inherit;
  font-size: 0.68rem;
  padding: 0.1rem 0.45rem;
  cursor: pointer;
}
.filter-mode-btn:hover { color: #aaa; }
.filter-mode-btn--active {
  background: #2a2a2a;
  color: #ddd;
}
.filter-mode-btn + .filter-mode-btn { border-left: 1px solid #333; }
```

**Step 5: Run tests**

```bash
cd frontend && npx vitest run src/components/FilterBar.test.tsx
```
Expected: all pass.

**Step 6: Commit**

```bash
git add frontend/src/components/FilterBar.tsx frontend/src/components/FilterBar.test.tsx frontend/src/index.css
git commit -m "feat: add ID input filter with AND/OR toggle to filter bar"
```

---

### Task 5: ID filter — Supabase query in usePermutationsDB

**Files:**
- Modify: `frontend/src/usePermutationsDB.ts`

**Step 1: Apply ID filter to the load() query**

In `usePermutationsDB.ts`, in the `load` function, after the existing `if (filters.shift)` line, add:

```ts
const idList = filters.idInput.trim()
  ? filters.idInput.split(',').map(s => Number(s.trim())).filter(n => !isNaN(n) && n > 0)
  : []

if (idList.length > 0) {
  const useAnd = idList.length > 4 && filters.idMode === 'and'
  if (useAnd) {
    q = q.in('keeper_1_id', idList).in('burner_1_id', idList).in('keeper_2_id', idList).in('burner_2_id', idList)
  } else {
    const ids = idList.join(',')
    q = q.or(`keeper_1_id.in.(${ids}),burner_1_id.in.(${ids}),keeper_2_id.in.(${ids}),burner_2_id.in.(${ids})`)
  }
}
```

**Step 2: Manual test**

Run the dev server, type a known check ID into the IDs input, and verify only permutations containing that check appear.

**Step 3: Commit**

```bash
git add frontend/src/usePermutationsDB.ts
git commit -m "feat: apply ID filter to Supabase permutations query"
```

---

### Task 6: DB migration — add eth_price and total_cost columns

**Files:**
- Create: `supabase/migrations/008_prices.sql`

**Step 1: Write the migration**

```sql
-- Add per-check price column
ALTER TABLE tokenstr_checks
  ADD COLUMN IF NOT EXISTS eth_price FLOAT;

-- Add denormalized total cost for all 4 leaf checks
ALTER TABLE permutations
  ADD COLUMN IF NOT EXISTS total_cost FLOAT;

-- Index for range queries on cost
CREATE INDEX IF NOT EXISTS permutations_total_cost_idx ON permutations (total_cost);

-- Helper: re-sync total_cost for all permutations involving a given token
CREATE OR REPLACE FUNCTION update_permutation_costs(p_token_id integer)
RETURNS void LANGUAGE sql AS $$
  UPDATE permutations p
  SET total_cost =
    tc1.eth_price + tc2.eth_price + tc3.eth_price + tc4.eth_price
  FROM
    tokenstr_checks tc1,
    tokenstr_checks tc2,
    tokenstr_checks tc3,
    tokenstr_checks tc4
  WHERE
    tc1.token_id = p.keeper_1_id AND
    tc2.token_id = p.burner_1_id AND
    tc3.token_id = p.keeper_2_id AND
    tc4.token_id = p.burner_2_id AND
    tc1.eth_price IS NOT NULL AND
    tc2.eth_price IS NOT NULL AND
    tc3.eth_price IS NOT NULL AND
    tc4.eth_price IS NOT NULL AND
    (
      p.keeper_1_id = p_token_id OR
      p.burner_1_id = p_token_id OR
      p.keeper_2_id = p_token_id OR
      p.burner_2_id = p_token_id
    );
$$;

-- Helper: backfill total_cost for all permutations at once (used by backfill script)
CREATE OR REPLACE FUNCTION backfill_permutation_costs()
RETURNS integer LANGUAGE sql AS $$
  UPDATE permutations p
  SET total_cost =
    tc1.eth_price + tc2.eth_price + tc3.eth_price + tc4.eth_price
  FROM
    tokenstr_checks tc1,
    tokenstr_checks tc2,
    tokenstr_checks tc3,
    tokenstr_checks tc4
  WHERE
    tc1.token_id = p.keeper_1_id AND
    tc2.token_id = p.burner_1_id AND
    tc3.token_id = p.keeper_2_id AND
    tc4.token_id = p.burner_2_id AND
    tc1.eth_price IS NOT NULL AND
    tc2.eth_price IS NOT NULL AND
    tc3.eth_price IS NOT NULL AND
    tc4.eth_price IS NOT NULL;

  SELECT count(*)::integer FROM permutations WHERE total_cost IS NOT NULL;
$$;
```

**Step 2: Apply the migration**

Run this SQL in the Supabase Dashboard → SQL Editor, or push via Supabase CLI:
```bash
supabase db push
```

**Step 3: Commit**

```bash
git add supabase/migrations/008_prices.sql
git commit -m "feat: add eth_price to tokenstr_checks, total_cost to permutations"
```

---

### Task 7: Backfill prices script

**Files:**
- Create: `backend/scripts/backfill-prices.ts`

**Step 1: Write the script**

```ts
/**
 * backfill-prices.ts — fetches nftForSale() prices from the TokenStrategy contract
 * for all checks in tokenstr_checks and populates eth_price.
 * Then calls backfill_permutation_costs() to fill total_cost in permutations.
 *
 * Usage:
 *   npx tsx scripts/backfill-prices.ts
 *
 * Required env vars (same .env as backfill.ts):
 *   SUPABASE_URL, SUPABASE_SERVICE_KEY, ALCHEMY_API_KEY
 */

import { createPublicClient, http, formatEther } from 'viem'
import { mainnet } from 'viem/chains'
import { createClient } from '@supabase/supabase-js'

const SUPABASE_URL        = process.env.SUPABASE_URL!
const SUPABASE_SERVICE_KEY = process.env.SUPABASE_SERVICE_KEY!
const ALCHEMY_KEY         = process.env.ALCHEMY_API_KEY!
const TOKEN_STRATEGY      = '0x2090Dc81F42f6ddD8dEaCE0D3C3339017417b0Dc' as const
const BATCH               = 500

if (!SUPABASE_URL || !SUPABASE_SERVICE_KEY || !ALCHEMY_KEY) {
  console.error('Missing env vars.')
  process.exit(1)
}

const supabase = createClient(SUPABASE_URL, SUPABASE_SERVICE_KEY)

const viemClient = createPublicClient({
  chain: mainnet,
  transport: http(`https://eth-mainnet.g.alchemy.com/v2/${ALCHEMY_KEY}`),
  batch: { multicall: true },
})

const NFT_FOR_SALE_ABI = [{
  name: 'nftForSale',
  type: 'function',
  stateMutability: 'view',
  inputs: [{ name: 'tokenId', type: 'uint256' }],
  outputs: [{ name: '', type: 'uint256' }],
}] as const

async function main() {
  // 1. Fetch all token IDs from tokenstr_checks
  const { data: rows, error } = await supabase
    .from('tokenstr_checks')
    .select('token_id')
  if (error) throw error

  const tokenIds = (rows ?? []).map((r: { token_id: number }) => r.token_id)
  console.log(`Found ${tokenIds.length} checks. Fetching prices...`)

  let updated = 0

  // 2. Batch-call nftForSale() for all token IDs
  for (let start = 0; start < tokenIds.length; start += BATCH) {
    const batch = tokenIds.slice(start, start + BATCH)
    console.log(`Batch ${Math.floor(start / BATCH) + 1}/${Math.ceil(tokenIds.length / BATCH)}: tokens ${batch[0]}…${batch[batch.length - 1]}`)

    const results = await Promise.allSettled(
      batch.map(id =>
        viemClient.readContract({
          address: TOKEN_STRATEGY,
          abi: NFT_FOR_SALE_ABI,
          functionName: 'nftForSale',
          args: [BigInt(id)],
        })
      )
    )

    const upsertRows = batch
      .map((tokenId, i) => {
        const result = results[i]
        if (result.status !== 'fulfilled') return null
        const weiPrice = result.value as bigint
        const ethPrice = parseFloat(formatEther(weiPrice))
        return { token_id: tokenId, eth_price: ethPrice }
      })
      .filter(Boolean)

    if (upsertRows.length > 0) {
      const { error: upsertErr } = await supabase
        .from('tokenstr_checks')
        .upsert(upsertRows, { onConflict: 'token_id' })
      if (upsertErr) throw upsertErr
      updated += upsertRows.length
      console.log(`  Updated ${upsertRows.length} prices (${updated} total)`)
    }
  }

  // 3. Backfill total_cost in permutations
  console.log('\nBackfilling permutation total_cost...')
  const { data: count, error: rpcErr } = await supabase.rpc('backfill_permutation_costs')
  if (rpcErr) throw rpcErr
  console.log(`Done. ${count} permutations have a total_cost.`)
}

main().catch(err => { console.error(err); process.exit(1) })
```

**Step 2: Run it**

```bash
cd backend && SUPABASE_URL=... SUPABASE_SERVICE_KEY=... ALCHEMY_API_KEY=... npx tsx scripts/backfill-prices.ts
```

Expected output: logs each batch, finishes with `X permutations have a total_cost.`

**Step 3: Verify in Supabase Dashboard**

Check that `tokenstr_checks.eth_price` is populated and `permutations.total_cost` is non-null for most rows.

**Step 4: Commit**

```bash
git add backend/scripts/backfill-prices.ts
git commit -m "feat: backfill-prices script — nftForSale() prices + permutation total_cost"
```

---

### Task 8: Webhook — sync eth_price on token upsert

**Files:**
- Modify: `supabase/functions/tokenstr-webhook/index.ts`

**Step 1: Add nftForSale raw eth_call helper**

The TokenStrategy contract's `nftForSale(uint256)` function selector is `keccak256("nftForSale(uint256)").slice(0,4)`. Compute it by running:
```bash
node -e "const {keccak256, toHex} = require('viem'); console.log(keccak256(toHex('nftForSale(uint256)')).slice(0,10))"
```
Expected result: `0xf8a2810f` — verify and use that value.

Add to `tokenstr-webhook/index.ts` after the existing `ownerOfCalldata` function:

```ts
// nftForSale(uint256) = 0xf8a2810f  (verify: keccak256("nftForSale(uint256)").slice(0,8))
function nftForSaleCalldata(tokenId: number): string {
  return '0xf8a2810f' + tokenId.toString(16).padStart(64, '0')
}

function decodeUint256(hex: string): bigint {
  return BigInt(hex.slice(0, 66))  // first 32 bytes
}
```

**Step 2: Add a fetchEthPrice helper**

```ts
async function fetchEthPrice(tokenId: number, alchemyKey: string): Promise<number | null> {
  const rpcUrl = `https://eth-mainnet.g.alchemy.com/v2/${alchemyKey}`
  const result = await ethCall(rpcUrl, TOKEN_STRATEGY_ADDRESS, nftForSaleCalldata(tokenId))
  if (!result) return null
  const weiPrice = decodeUint256(result.slice(2))
  // Convert wei to ETH: divide by 1e18
  return Number(weiPrice) / 1e18
}

const TOKEN_STRATEGY_ADDRESS = '0x2090dc81f42f6ddd8deace0d3c3339017417b0dc'
```

**Step 3: Update refetchAndUpsert to include eth_price, then sync permutations**

In `refetchAndUpsert`, add a `fetchEthPrice` call alongside the existing calls:

```ts
const [uriResult, checkResult, ownerResult, ethPrice] = await Promise.all([
  ethCall(rpcUrl, CHECKS_CONTRACT, tokenURICalldata(tokenId)),
  ethCall(rpcUrl, CHECKS_CONTRACT, getCheckCalldata(tokenId)),
  ethCall(rpcUrl, CHECKS_CONTRACT, ownerOfCalldata(tokenId)),
  fetchEthPrice(tokenId, alchemyKey),
])
```

Add `eth_price: ethPrice` to the upsert object:

```ts
await supabase.from('tokenstr_checks').upsert({
  token_id:      tokenId,
  // ... existing fields ...
  eth_price:     ethPrice,
  last_synced_at: new Date().toISOString(),
}, { onConflict: 'token_id' })

// Re-sync total_cost for all permutations involving this check
await supabase.rpc('update_permutation_costs', { p_token_id: tokenId })
```

**Step 4: Deploy the updated webhook**

```bash
supabase functions deploy tokenstr-webhook
```

**Step 5: Commit**

```bash
git add supabase/functions/tokenstr-webhook/index.ts
git commit -m "feat: sync eth_price in tokenstr-webhook, update permutation total_cost"
```

---

### Task 9: Price slider — Filters type + DB query

**Files:**
- Modify: `frontend/src/usePermutationsDB.ts`

The `Filters` type already has `minCost` and `maxCost` from Task 3. This task wires them into the Supabase query.

**Step 1: Apply cost filter to the load() query**

In `usePermutationsDB.ts`, in the `load` function, after the ID filter block, add:

```ts
if (filters.minCost !== null) q = q.gte('total_cost', filters.minCost)
if (filters.maxCost !== null) q = q.lte('total_cost', filters.maxCost)
```

**Step 2: Fetch price bounds for the slider and export from usePermutationsDB**

Add a `fetchPriceBounds` async function and call it from a new exported `usePriceBounds` hook:

```ts
export function usePriceBounds(enabled: boolean) {
  const [bounds, setBounds] = useState<{ min: number; max: number } | null>(null)

  useEffect(() => {
    if (!enabled || !supabase) return
    Promise.all([
      supabase
        .from('tokenstr_checks')
        .select('eth_price')
        .not('eth_price', 'is', null)
        .order('eth_price', { ascending: true })
        .limit(1),
      supabase
        .from('tokenstr_checks')
        .select('eth_price')
        .not('eth_price', 'is', null)
        .order('eth_price', { ascending: false })
        .limit(1),
    ]).then(([minRes, maxRes]) => {
      const minPrice = (minRes.data?.[0] as { eth_price: number } | undefined)?.eth_price ?? 0
      const maxPrice = (maxRes.data?.[0] as { eth_price: number } | undefined)?.eth_price ?? 0
      // Slider bounds = 4 × cheapest individual to 4 × most expensive
      setBounds({ min: minPrice * 4, max: maxPrice * 4 })
    })
  }, [enabled])

  return bounds
}
```

**Step 3: Commit**

```bash
git add frontend/src/usePermutationsDB.ts
git commit -m "feat: apply cost range filter to DB query, add usePriceBounds hook"
```

---

### Task 10: Price slider — UI, CSS, App.tsx wiring

**Files:**
- Modify: `frontend/src/components/FilterBar.tsx`
- Modify: `frontend/src/index.css`
- Modify: `frontend/src/App.tsx`

**Step 1: Add priceRange prop to FilterBar**

Add to `FilterBarProps`:
```ts
interface FilterBarProps {
  filters: Filters
  onChange: (f: Filters) => void
  visible: number
  onShuffle?: () => void
  priceRange?: { min: number; max: number }  // if provided, show the price slider
}
```

**Step 2: Add the price slider JSX**

The filter bar gets a second row when `priceRange` is provided. The existing row stays identical. Add after the closing `</div>` of the first-row controls (before the end of the outer `.filter-strip`), adding a conditional second row:

```tsx
export function FilterBar({ filters, onChange, visible, onShuffle, priceRange }: FilterBarProps) {
  // ... existing state and helpers ...

  const currentMin = filters.minCost ?? priceRange?.min ?? 0
  const currentMax = filters.maxCost ?? priceRange?.max ?? 0

  return (
    <div className={`filter-strip${priceRange ? ' filter-strip--two-row' : ''}`}>
      {/* ── Row 1: existing filters ── */}
      <div className="filter-row">
        <FilterSelect label="Checks"     options={CHECKS_OPTIONS}     value={filters.checks}    onChange={v => update('checks', v)} />
        <FilterSelect label="Color Band" options={COLOR_BAND_OPTIONS} value={filters.colorBand} onChange={v => update('colorBand', v)} />
        <FilterSelect label="Gradient"   options={GRADIENT_OPTIONS}   value={filters.gradient}  onChange={v => update('gradient', v)} />
        <FilterSelect label="Speed"      options={SPEED_OPTIONS}      value={filters.speed}     onChange={v => update('speed', v)} />
        <FilterSelect label="Shift"      options={SHIFT_OPTIONS}      value={filters.shift}     onChange={v => update('shift', v)} />

        <label className="filter-select-label">
          <span className="filter-select-name">IDs</span>
          <input
            className="filter-id-input"
            type="text"
            placeholder="e.g. 123, 456"
            value={filters.idInput}
            onChange={e => update('idInput', e.target.value)}
          />
        </label>

        {parseIdCount(filters.idInput) > 4 && (
          <div className="filter-mode-toggle">
            <button type="button" className={`filter-mode-btn${filters.idMode === 'and' ? ' filter-mode-btn--active' : ''}`} onClick={() => update('idMode', 'and')} aria-label="AND">AND</button>
            <button type="button" className={`filter-mode-btn${filters.idMode === 'or' ? ' filter-mode-btn--active' : ''}`} onClick={() => update('idMode', 'or')} aria-label="OR">OR</button>
          </div>
        )}

        <span className="filter-count">Showing {visible}</span>
        {isActive && <button type="button" className="filter-clear" onClick={clearAll}>Clear</button>}
        {onShuffle && (
          <button type="button" className="filter-shuffle" onClick={handleShuffle} disabled={cooldown > 0}>
            {cooldown > 0 ? `↻ ${cooldown}s` : '↻ Shuffle'}
          </button>
        )}
      </div>

      {/* ── Row 2: price range slider (Token Works only) ── */}
      {priceRange && (
        <div className="filter-row filter-row--price">
          <span className="filter-select-name">Cost</span>
          <span className="filter-price-val">{currentMin.toFixed(3)}</span>
          <div className="filter-price-track">
            <input
              type="range"
              className="filter-price-range filter-price-range--min"
              min={priceRange.min}
              max={priceRange.max}
              step={(priceRange.max - priceRange.min) / 200}
              value={currentMin}
              onChange={e => {
                const v = parseFloat(e.target.value)
                onChange({ ...filters, minCost: v <= priceRange.min ? null : v })
              }}
            />
            <input
              type="range"
              className="filter-price-range filter-price-range--max"
              min={priceRange.min}
              max={priceRange.max}
              step={(priceRange.max - priceRange.min) / 200}
              value={currentMax}
              onChange={e => {
                const v = parseFloat(e.target.value)
                onChange({ ...filters, maxCost: v >= priceRange.max ? null : v })
              }}
            />
          </div>
          <span className="filter-price-val">{currentMax.toFixed(3)} ETH</span>
        </div>
      )}
    </div>
  )
}
```

Note: `isActive` must now also check `minCost`/`maxCost`. Update it:
```ts
const isActive = hasActiveFilters(filters)
```

**Step 3: Add CSS**

In `index.css`, update `.filter-strip` and add new classes:

```css
/* Allow two rows */
.filter-strip {
  /* existing properties stay — change height to min-height */
  min-height: 40px;
  height: auto;
  flex-wrap: wrap;
  align-items: stretch;
}

.filter-strip--two-row {
  /* no extra properties needed — wrapping handled by flex-wrap */
}

/* Each row */
.filter-row {
  display: flex;
  align-items: center;
  gap: 0.75rem;
  width: 100%;
  height: 40px;
  padding: 0 28px;
}

.filter-row--price {
  height: 32px;
  border-top: 1px solid #1a1a1a;
  padding: 0 28px;
  gap: 0.6rem;
}

/* Price range slider track container */
.filter-price-track {
  position: relative;
  flex: 1;
  max-width: 200px;
  height: 20px;
  display: flex;
  align-items: center;
}

.filter-price-range {
  position: absolute;
  left: 0; right: 0;
  width: 100%;
  -webkit-appearance: none;
  appearance: none;
  background: transparent;
  pointer-events: none;
  height: 4px;
}

.filter-price-range::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  pointer-events: all;
  width: 14px;
  height: 14px;
  border-radius: 50%;
  background: #ccc;
  cursor: pointer;
  border: none;
}

.filter-price-range::-webkit-slider-runnable-track {
  background: #333;
  height: 4px;
  border-radius: 2px;
}

.filter-price-val {
  font-size: 0.68rem;
  color: #888;
  white-space: nowrap;
  flex-shrink: 0;
  min-width: 3.5rem;
}
```

Also update `.grid-viewport--with-filters` and add a tall variant. The two-row filter bar is 40px + 32px = 72px, so grid offset becomes 48 + 72 = 120px:

```css
.grid-viewport--with-filters {
  top: 88px;   /* 48px navbar + 40px filter (single row) */
}

.grid-viewport--with-filters-tall {
  top: 120px;  /* 48px navbar + 72px filter (two rows) */
}
```

**Step 4: Update InfiniteGrid.tsx to accept filtersTall prop**

```tsx
interface Props {
  // existing...
  filtersTall?: boolean
}

export function InfiniteGrid({ ..., filtersTall }: Props) {
  // Replace the className computation:
  const viewportClass = `grid-viewport${
    hasFilters
      ? filtersTall
        ? ' grid-viewport--with-filters-tall'
        : ' grid-viewport--with-filters'
      : ''
  }`

  // Use viewportClass on both viewport divs
}
```

**Step 5: Wire everything in App.tsx**

```tsx
import { usePriceBounds } from './usePermutationsDB'

// Add after existing hooks:
const priceBoundsEnabled = dbMode && viewMode === 'token-works'
const priceBounds = usePriceBounds(priceBoundsEnabled)

// Update FilterBar usage:
<FilterBar
  filters={filters}
  onChange={setFilters}
  visible={...}
  onShuffle={...}
  priceRange={priceBoundsEnabled ? priceBounds ?? undefined : undefined}
/>

// Update InfiniteGrid usage:
<InfiniteGrid
  ...
  filtersTall={!!(showFilters && priceBoundsEnabled && priceBounds)}
/>
```

**Step 6: Run all tests**

```bash
cd frontend && npx vitest run
```
Expected: all pass.

**Step 7: Manual test**

Run `npm run dev`. In Token Works mode: verify the price slider appears on a second row and filters results correctly. In My Checks mode: verify no slider row appears.

**Step 8: Commit**

```bash
git add frontend/src/components/FilterBar.tsx frontend/src/index.css frontend/src/App.tsx frontend/src/components/InfiniteGrid.tsx frontend/src/usePermutationsDB.ts
git commit -m "feat: price range slider in Token Works filter bar"
```

---

## Summary of all commits

1. `feat: click blank grid space to close side panel`
2. `feat: reorder checks filter [20,10,5,4,1], remove 40 and 80`
3. `feat: add ID filter logic to Filters type and matchesFilters`
4. `feat: add ID input filter with AND/OR toggle to filter bar`
5. `feat: apply ID filter to Supabase permutations query`
6. `feat: add eth_price to tokenstr_checks, total_cost to permutations`
7. `feat: backfill-prices script — nftForSale() prices + permutation total_cost`
8. `feat: sync eth_price in tokenstr-webhook, update permutation total_cost`
9. `feat: apply cost range filter to DB query, add usePriceBounds hook`
10. `feat: price range slider in Token Works filter bar`
